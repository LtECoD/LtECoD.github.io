<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>【译】深度生成建模（二）：为什么需要深度生成模型？ | 豌豆道场</title>
<meta name=keywords content="深度生成模型"><meta name=description content="1.1 人工智能不仅仅是决策 在思考深度生成建模之前，先看一个简单的例子：假如我们已经训练了一个对动物图像$\bm{x}\in\mathbb{Z}^"><meta name=author content="神思豌豆"><link rel=canonical href=https://ltecod.github.io/posts/2023/%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%BA%8C/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.911a1fad53b80bfa5512ea084165c804bc8c989d4e7944dbfc468ed661b8975f.css integrity="sha256-kRofrVO4C/pVEuoIQWXIBLyMmJ1OeUTb/EaO1mG4l18=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://ltecod.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ltecod.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ltecod.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ltecod.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ltecod.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-3H93LFDVRR"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3H93LFDVRR")</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.css><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap" rel=stylesheet><script async src="https://www.googletagmanager.com/gtag/js?id=G-3H93LFDVRR"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3H93LFDVRR",{anonymize_ip:!1})}</script><meta property="og:title" content="【译】深度生成建模（二）：为什么需要深度生成模型？"><meta property="og:description" content="1.1 人工智能不仅仅是决策 在思考深度生成建模之前，先看一个简单的例子：假如我们已经训练了一个对动物图像$\bm{x}\in\mathbb{Z}^"><meta property="og:type" content="article"><meta property="og:url" content="https://ltecod.github.io/posts/2023/%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%BA%8C/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-10T22:59:17+08:00"><meta property="article:modified_time" content="2023-11-10T22:59:17+08:00"><meta property="og:site_name" content="豌豆道场"><meta property="og:see_also" content="https://ltecod.github.io/posts/2023/%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%B8%80/"><meta name=twitter:card content="summary"><meta name=twitter:title content="【译】深度生成建模（二）：为什么需要深度生成模型？"><meta name=twitter:description content="1.1 人工智能不仅仅是决策 在思考深度生成建模之前，先看一个简单的例子：假如我们已经训练了一个对动物图像$\bm{x}\in\mathbb{Z}^"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://ltecod.github.io/posts/"},{"@type":"ListItem","position":3,"name":"【译】深度生成建模（二）：为什么需要深度生成模型？","item":"https://ltecod.github.io/posts/2023/%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%BA%8C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"【译】深度生成建模（二）：为什么需要深度生成模型？","name":"【译】深度生成建模（二）：为什么需要深度生成模型？","description":"1.1 人工智能不仅仅是决策 在思考深度生成建模之前，先看一个简单的例子：假如我们已经训练了一个对动物图像$\\bm{x}\\in\\mathbb{Z}^","keywords":["深度生成模型"],"articleBody":"1.1 人工智能不仅仅是决策 在思考深度生成建模之前，先看一个简单的例子：假如我们已经训练了一个对动物图像$\\bm{x}\\in\\mathbb{Z}^D$分类的深度神经网络，图像的标签表示为$y\\in\\mathcal{Y}$, 其中$\\mathcal{Y}$={cat, dog, horse}；假设这个神经网络已训练完成且能够对一个样本进行正确分类。目前为止还不错，对吧？但如文献[1]所指出，在输入图像中添加一些噪声可能会导致完全错误的分类结果。图1.1展示了一个添加噪声改变预测标签概率的例子；然而，加入的噪声几乎没有改变图像的内容（至少对人类来说）。\n这个例子表明，用于参数化条件分布$p(y|\\bm{x})$的神经网络似乎缺乏对图像的语义理解。由此，我们可以认为判别式学习对于决策系统或人工智能是不够的。对一个机器学习系统来说，如果无法理解或表达所处环境的不确定性，那么它做出的决策是不可靠的。例如：当少量的噪音就能改变系统内部的信念并导致决策方向的偏移，我们如何信任这样的系统？当系统对所处环境一无所知，我们如何与之沟通？\n为了说明“ 不确定性 （uncertainty）”和“ 理解 （understanding）”两个概念，以二分类任务为例，类别分别用orange和blue两种颜色表示。假定有一些二维标注样本（图1.2左），还有一个待测试样本（图1.2中的✖️）。我们有两种方式构建分类系统：第一是基于条件概率$p(y|\\bm{x})$（图1.2中）在标注样本上学习；第二则是通过联合分布$p(\\bm{x},y)=p(y|\\bm{x})p(\\bm{x})$（图1.2右）在标注样本上学习。\n如果使用判别式方法，即学习条件概率分布$(y|\\bm{x})$，那么可以清晰地画出两个类别之间的分界线。然后可以看到✖️距离orange区域非常远，所以分类器认为这个样本属于blue类的概率更大，说明分类器对分类结果非常确定。\n但是，如果额外学习一个边缘概率$p(\\bm{x})$，可以看到✖️不仅距离类别边界线非常远，而且距离标注的blue样本也非常远。这说明✖️远离标注样本高概率出现的区域，因此✖️的边缘概率$p(\\bm{x}=\\times)$取值低，则联合概率$p(\\bm{x}=\\times,y=\\text{blue})$同样取值低，因此模型对分类的结果并不确定。\n这个例子表明，理解所处环境是可靠人工智能系统的特征之一。针对这个目标，只进行判别式学习是不够的，还应使用概率论语言量化对周围环境的信念[2, 3]，所以我们认为对分布$p(\\bm{x})$进行建模是非常重要的，它有如下的必要性： 评估对$\\bm{x}$的置信度或对环境的不确定程度； 对决策结果进行加权； 生成新的数据实例。 通常来讲，在深度学习中，生成式模型指代哪些可以生成数据实例的模型，但我们尝试展示了生成模型更广泛的应用，这对于构建人工智能系统来说或许非常重要。此外，对数据的生成式过程建模对与理解感兴趣的现象至关重要[3，4]。针对判别任务，我们倾向于关注$p(\\bm{x},y)=p(y|\\bm{x})p(\\bm{x})$，如前所述，这比单独的条件分布更具优势。\n1.2 生成式建模可以用在什么领域？ 随着神经网络和算力的发展，深度生成建模已经成为人工智能领域的前沿方向之一。它的应用横跨多种不同的数据模态，例如：文本分析[5]、图像分析[6]、音频分析[7]，以及不同的学习范式，例如主动学习[8]、强化学习[9]。图1.3展示了深度生成建模潜在的应用。 在某些任务中，直接生成或着通过修改已有样本的特征获取新的数据实例非常重要。但在主动学习这样的任务中，找出低置信度的样本更为重要。对于强化学习情况又另当别论，生成下一步最有可能的环境状态对于Agent的行动决策非常重要。而对于医学应用，生成模型提供的信息比单纯的判别式模型更具价值。如果一个人工智能系统知道自己所不知道的，那么它就具备作为一个独立专家的可能性。\n以上例子清楚地表明，很多领域都可以从生成模型中受益。也许成熟的人工智能系统会需要多样的能力，但正如以上案例所示，我们认为生成式建模无疑是最重要的能力之一。\n1.3 如何实现生成式建模？ 在介绍了生成式建模的重要性和广泛应用性之后，我们应该思考如何用模型实现生成式建模，换句话说，如何计算我们多次提到的$p(\\bm{x})$。\n目前已有的生成式建模方法分为四类（图1.4）: 自回归式生成模型（Autoregressive Gnerative Models, ARM） 流模型（Flow based models） 隐变量模型（Latent variable models） 能量模型（Energy-based models） 我们目前所讨论的建模方法都可以不用深度神经网络实现。尽管如此，但神经网络是灵活且强大的，且被广泛用于参数化生成模型。因此，我们从现在开始主要关注深度生成模型，即基于深度神经网络构建的生成模型。\n以上对生成模型的分类仅作为帮助我们浏览本书的原则，并非一成不变。就我个人而言，我不太喜欢花太多时间对科学方法进行分类和标记，因为这一般会导致分歧和门槛。此外，还有一组基于分数匹配[12-14]的模型无法采用上述分类原则。然而，正如[14]所指出的，这些模型与隐变量模型有很多相似之处（如果我们将随机过程的连续步骤视为隐变量），因此，我们将其视为隐变量模型。\n1.3.1 自回归生成模型 在自回归生成模型中，样本的概率分布$p(\\bm{x})$以自回归的方式分解为: $$ p(\\bm{x})=p(x_0)\\prod_{i=1}^{D}p(x_i|\\bm{x}_{","wordCount":"6324","inLanguage":"zh","datePublished":"2023-11-10T22:59:17+08:00","dateModified":"2023-11-10T22:59:17+08:00","author":{"@type":"Person","name":"神思豌豆"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ltecod.github.io/posts/2023/%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%BA%8C/"},"publisher":{"@type":"Organization","name":"豌豆道场","logo":{"@type":"ImageObject","url":"https://ltecod.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ltecod.github.io accesskey=h title="豌豆道场 (Alt + H)">豌豆道场</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ltecod.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://ltecod.github.io/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ltecod.github.io>主页</a>&nbsp;»&nbsp;<a href=https://ltecod.github.io/posts/>文章</a></div><h1 class=post-title>【译】深度生成建模（二）：为什么需要深度生成模型？</h1><div class=post-meta><span title='2023-11-10 22:59:17 +0800 CST'>2023-11-10</span>&nbsp;·&nbsp;神思豌豆</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#11-%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e4%b8%8d%e4%bb%85%e4%bb%85%e6%98%af%e5%86%b3%e7%ad%96 aria-label="1.1 人工智能不仅仅是决策">1.1 人工智能不仅仅是决策</a></li><li><a href=#12-%e7%94%9f%e6%88%90%e5%bc%8f%e5%bb%ba%e6%a8%a1%e5%8f%af%e4%bb%a5%e7%94%a8%e5%9c%a8%e4%bb%80%e4%b9%88%e9%a2%86%e5%9f%9f aria-label="1.2 生成式建模可以用在什么领域？">1.2 生成式建模可以用在什么领域？</a></li><li><a href=#13-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%94%9f%e6%88%90%e5%bc%8f%e5%bb%ba%e6%a8%a1 aria-label="1.3 如何实现生成式建模？">1.3 如何实现生成式建模？</a><ul><li><a href=#131-%e8%87%aa%e5%9b%9e%e5%bd%92%e7%94%9f%e6%88%90%e6%a8%a1%e5%9e%8b aria-label="1.3.1 自回归生成模型">1.3.1 自回归生成模型</a></li><li><a href=#132-%e6%b5%81%e6%a8%a1%e5%9e%8b aria-label="1.3.2 流模型">1.3.2 流模型</a></li><li><a href=#133-%e9%9a%90%e5%8f%98%e9%87%8f%e6%a8%a1%e5%9e%8b aria-label="1.3.3 隐变量模型">1.3.3 隐变量模型</a></li><li><a href=#134-%e8%83%bd%e9%87%8f%e6%a8%a1%e5%9e%8b aria-label="1.3.4 能量模型">1.3.4 能量模型</a></li><li><a href=#135-%e6%80%bb%e7%bb%93 aria-label="1.3.5 总结">1.3.5 总结</a></li></ul></li><li><a href=#14-%e6%9c%ac%e4%b9%a6%e7%9a%84%e7%9b%ae%e7%9a%84%e5%92%8c%e5%86%85%e5%ae%b9 aria-label="1.4 本书的目的和内容">1.4 本书的目的和内容</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae aria-label=参考文献>参考文献</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=11-人工智能不仅仅是决策>1.1 人工智能不仅仅是决策<a hidden class=anchor aria-hidden=true href=#11-人工智能不仅仅是决策>#</a></h2><p>在思考深度生成建模之前，先看一个简单的例子：假如我们已经训练了一个对动物图像$\bm{x}\in\mathbb{Z}^D$分类的深度神经网络，图像的标签表示为$y\in\mathcal{Y}$, 其中$\mathcal{Y}$={cat, dog, horse}；假设这个神经网络已训练完成且能够对一个样本进行正确分类。目前为止还不错，对吧？但如文献[1]所指出，在输入图像中添加一些噪声可能会导致完全错误的分类结果。图1.1展示了一个添加噪声改变预测标签概率的例子；然而，加入的噪声几乎没有改变图像的内容（至少对人类来说）。</p><figure class=align-center><img loading=lazy src=/2023_image/3.1.add_noise.png#center width=80%></figure><p>这个例子表明，用于参数化条件分布$p(y|\bm{x})$的神经网络似乎缺乏对图像的语义理解。由此，我们可以认为判别式学习对于决策系统或人工智能是不够的。对一个机器学习系统来说，如果无法<strong>理解</strong>或表达所处环境的<strong>不确定性</strong>，那么它做出的决策是不可靠的。例如：当少量的噪音就能改变系统内部的信念并导致决策方向的偏移，我们如何信任这样的系统？当系统对所处环境一无所知，我们如何与之沟通？</p><p>为了说明“<b style=font-family:STKaiti>
不确定性
</b>（uncertainty）”和“<b style=font-family:STKaiti>
理解
</b>（understanding）”两个概念，以二分类任务为例，类别分别用orange和blue两种颜色表示。假定有一些二维标注样本（图1.2左），还有一个待测试样本（图1.2中的✖️）。我们有两种方式构建分类系统：第一是基于条件概率$p(y|\bm{x})$（图1.2中）在标注样本上学习；第二则是通过联合分布$p(\bm{x},y)=p(y|\bm{x})p(\bm{x})$（图1.2右）在标注样本上学习。</p><figure class=align-center><img loading=lazy src=/2023_image/3.2.png#center width=80%></figure><p>如果使用判别式方法，即学习条件概率分布$(y|\bm{x})$，那么可以清晰地画出两个类别之间的分界线。然后可以看到✖️距离orange区域非常远，所以分类器认为这个样本属于blue类的概率更大，说明分类器对分类结果非常确定。</p><p>但是，如果额外学习一个边缘概率$p(\bm{x})$，可以看到✖️不仅距离类别边界线非常远，而且距离标注的blue样本也非常远。这说明✖️远离标注样本高概率出现的区域，因此✖️的边缘概率$p(\bm{x}=\times)$取值低，则联合概率$p(\bm{x}=\times,y=\text{blue})$同样取值低，因此模型对分类的结果并不确定。</p><p>这个例子表明，理解所处环境是可靠人工智能系统的特征之一。针对这个目标，只进行判别式学习是不够的，还应使用概率论语言量化对周围环境的信念[2, 3]，所以我们认为对分布$p(\bm{x})$进行建模是非常重要的，它有如下的必要性：<div class="block note"><p><ul><li>评估对$\bm{x}$的置信度或对环境的不确定程度；</li><li>对决策结果进行加权；</li><li>生成新的数据实例。</li></ul></p></div></p><p>通常来讲，在深度学习中，生成式模型指代哪些可以生成数据实例的模型，但我们尝试展示了生成模型更广泛的应用，这对于构建人工智能系统来说或许非常重要。此外，对数据的生成式过程建模对与理解感兴趣的现象至关重要[3，4]。针对判别任务，我们倾向于关注$p(\bm{x},y)=p(y|\bm{x})p(\bm{x})$，如前所述，这比单独的条件分布更具优势。</p><h2 id=12-生成式建模可以用在什么领域>1.2 生成式建模可以用在什么领域？<a hidden class=anchor aria-hidden=true href=#12-生成式建模可以用在什么领域>#</a></h2><p>随着神经网络和算力的发展，深度生成建模已经成为人工智能领域的前沿方向之一。它的应用横跨多种不同的数据模态，例如：文本分析[5]、图像分析[6]、音频分析[7]，以及不同的学习范式，例如主动学习[8]、强化学习[9]。图1.3展示了深度生成建模潜在的应用。<figure class=align-center><img loading=lazy src=/2023_image/3.3.png#center width=80%></figure></p><p>在某些任务中，直接生成或着通过修改已有样本的特征获取新的数据实例非常重要。但在主动学习这样的任务中，找出低置信度的样本更为重要。对于强化学习情况又另当别论，生成下一步最有可能的环境状态对于Agent的行动决策非常重要。而对于医学应用，生成模型提供的信息比单纯的判别式模型更具价值。如果一个人工智能系统知道自己所不知道的，那么它就具备作为一个独立专家的可能性。</p><p>以上例子清楚地表明，很多领域都可以从生成模型中受益。也许成熟的人工智能系统会需要多样的能力，但正如以上案例所示，我们认为生成式建模无疑是最重要的能力之一。</p><h2 id=13-如何实现生成式建模>1.3 如何实现生成式建模？<a hidden class=anchor aria-hidden=true href=#13-如何实现生成式建模>#</a></h2><p>在介绍了生成式建模的重要性和广泛应用性之后，我们应该思考如何用模型实现生成式建模，换句话说，如何计算我们多次提到的$p(\bm{x})$。</p><p>目前已有的生成式建模方法分为四类（图1.4）:<div class="block note"><p><ul><li>自回归式生成模型（Autoregressive Gnerative Models, ARM）</li><li>流模型（Flow based models）</li><li>隐变量模型（Latent variable models）</li><li>能量模型（Energy-based models）</li></ul></p></div></p><figure class=align-center><img loading=lazy src=/2023_image/3.4.png#center width=80%></figure><p>我们目前所讨论的建模方法都可以不用深度神经网络实现。尽管如此，但神经网络是灵活且强大的，且被广泛用于参数化生成模型。因此，我们从现在开始主要关注深度生成模型，即基于深度神经网络构建的生成模型。</p><p>以上对生成模型的分类仅作为帮助我们浏览本书的原则，并非一成不变。就我个人而言，我不太喜欢花太多时间对科学方法进行分类和标记，因为这一般会导致分歧和门槛。此外，还有一组基于分数匹配[12-14]的模型无法采用上述分类原则。然而，正如[14]所指出的，这些模型与隐变量模型有很多相似之处（如果我们将随机过程的连续步骤视为隐变量），因此，我们将其视为隐变量模型。</p><h3 id=131-自回归生成模型>1.3.1 自回归生成模型<a hidden class=anchor aria-hidden=true href=#131-自回归生成模型>#</a></h3><p>在自回归生成模型中，样本的概率分布$p(\bm{x})$以自回归的方式分解为:
$$
p(\bm{x})=p(x_0)\prod_{i=1}^{D}p(x_i|\bm{x}_{&lt;i}),\tag{1.1}
$$</p><p>其中，$\bm{x}_{&lt;i}$表示$\bm{x}$中索引小于$i$的部分。</p><p>计算所有的条件概率$p(x_i|\bm{x}_{&lt;i})$是低效的。不过我们可以借助于因果卷积[7,15,16]等技术。第2章中深入讨论了自回归模型。</p><h3 id=132-流模型>1.3.2 流模型<a hidden class=anchor aria-hidden=true href=#132-流模型>#</a></h3><p>变量替换定理通过可逆变换$f$对随机变量的密度进行变换，为生成式模型提供了一种计算概率分布的方法[17]：
$$
p(\bm{x}) = p(\bm{z}=f(\bm{x}))|\bm{J}_{f(\bm{x})}|,\tag{1.2}
$$</p><p>其中，$\bm{J}_{f(\bm{x})}$表示Jacobian矩阵。</p><p>虽然$f$可由神经网络参数化，但神经网络的运算必须支持计算Jacobian矩阵，因此架构十分受限。
线性体积等价变换（linear, volume-preserving transformations）[18,19]是早期出现的变换方法，这种变换的Jacobian矩阵行列式$|\bm{J}_{f(\bm{x})}|=1$。后续工作基于矩阵行列式设计非线性变换，包括planar流[20]和Sylvester流[21,22]。另一类方法侧重于建模可逆变换，从而使Jacobian矩阵可计算，例如使用耦合层的RealNVP[23]。最近的工作利用可逆约束使任意神经网络都可以计算Jacobian矩阵行列式的近似[24-26]。</p><p>针对离散化数据，概率质量函数的体积无法进行变换，因此，变量替换定理采用如下形式：
$$
p(\bm{x}) = p(\bm{z}=f(\bm{x})).\tag{1.3}
$$
整数离散流提出使用带有舍入运算符的仿射耦合层来保证整数输出[27]。[28]对仿射偶合层做了进一步扩展。</p><p>所有利用变量替换定理的生成式模型统称为基于流的模型或简称为流模型。我们会在第三章讨论流模型。</p><h3 id=133-隐变量模型>1.3.3 隐变量模型<a hidden class=anchor aria-hidden=true href=#133-隐变量模型>#</a></h3><p>隐变量模型的基本思想是假设存在一个低维的隐空间并且数据的生成过程为：
$$
\begin{aligned}
&\bm{z}\sim p(\bm{z}) \\
&\bm{x}\sim p(\bm{x}|\bm{z}).
\end{aligned}
$$
其中隐变量$\bm{z}$就是样本$\bm{x}$在低维隐空间中的映射。</p><p>最为人熟知的隐变量模型可能是概率主成分分析[29]（pPCA），其假设$p(\bm{z})$和$p(\bm{x}|\bm{z})$都是高斯分布，而且$\bm{x}$和$\bm{z}$之间是线性相关的。</p><p>变分自编码器（Variationa Auto-Encoder，VAE）[30,31]是一种非线性版的pPCA。VAE使用变分推断估计后验概率$p(\bm{z}|\bm{x})$，并且利用神经网络对概率分布进行参数化。自从Kingma和Welling的论文[30]以及Rezende等人的论文[31]发表之后，很多VAE的扩展或变种被提出，包括对后验的改进[19,21,22,32]、对先验的改进[33,34]以及对解码器的改进[35]。也有一些工作对隐空间的拓扑结构做了约束，例如，球面隐空间[36]。无论是VAE还是pPCA，其中的所有分布都需要提前确定好，因此，这些模型也被称为预定义的（prescribed）模型，我们将在第四章讨论隐变量模型。</p><p>目前为止，自回归模型、流模型以及pPCA和VAE都以最大化对数概率似然为目标，这与数据分布和模型分布之间的KL散度密切相关。另一种不同的方法采用对抗损失，使用一个判别器$D(\cdot)$判断输入的样本是真实的样本还是由生成器隐式生成的样本，即$p(\bm{x}|\bm{z})=\sigma(\bm{x}-G(\bm{z}))$，其中$\sigma(\cdot)$表示狄拉克函数。这一类模型称为隐式（implicit）模型。生成对抗网络（Generative Adversarial Networks, GANs）是典型的隐式模型，能够生成逼真的图像，是最成功的深度生成模型之一。详见第七章。</p><h3 id=134-能量模型>1.3.4 能量模型<a hidden class=anchor aria-hidden=true href=#134-能量模型>#</a></h3><p>物理学中的能量函数$E(\bm{x})$以及玻尔兹曼分布，为生成式建模提供了一个有趣的角度:
$$
p(\bm{x})=\frac{\exp(-E(\bm{x}))}{Z}
$$
其中$Z=\sum_{\bm{x}}\exp(-E(\bm{x}))$表示配分函数。分布由幂能量函数定义，该幂能量函数通过配分函数$Z$归一化作为概率取值。尽管深入到物理学中会发现更多关于能量函数的内容，但我们不需要深究。[37]是研究能量模型一个很好的起点。</p><p>借由能量函数表示概率分布的生成模型称为能量模型（energy-based models，EBMs）。EBM背后的主要思想是建模能量函数并计算（更确切地说是近似地计算）配分函数。玻尔兹曼机（Boltzmann Machines）是一种典型的能量模型，它利用双线性映射作为能量函数，即$E(\bm{x})=\bm{x}^\top\bm{W}\bm{x}$。在玻尔兹曼机中引入隐变量就是受限玻尔兹曼机[41]$E(\bm{x}, \bm{z})=\bm{x}^\top\bm{W}\bm{z}$。玻尔兹曼机的概念可以进一步扩展到$\bm{x}$和$y$的联合分布，并用于判别式分类，例如受限玻尔兹曼机分类器[42]。研究表明，任意神经网络都可以用于参数化联合分布[43]。我们将在第六章中讨论能量模型。</p><h3 id=135-总结>1.3.5 总结<a hidden class=anchor aria-hidden=true href=#135-总结>#</a></h3><p>表1.1基于四个要素对比了生成式模型，包括训练的稳定性、是否需要计算似然函数、数据压缩是否无损、是否能用于表示学习：</p><figure class=align-center><img loading=lazy src=/2023_image/3.5.png#center width=80%></figure><p>所有基于似然概率的模型（自回归模型，流模型、能量模型，以及诸如VAE的预定义隐变量模型）均能够进行相对稳定的训练，而GAN这类隐式模型的训练过程则不稳定。对于VAE这样的预定义隐变量模型，无法精确地计算出似然概率，只能得到它的一个下界。与之相似，EBM需要计算配分函数才能得到思然概率，而计算配分函数相当困难。因此，EBM顶多可以提供未归一化的能量或近似概率。ARM能够计算似然概率；然而，自回归的方式导致采样过程极其缓慢。EBM需要基于蒙特卡罗方法生成样本，所以在高维数据上效率会很低。从数据压缩的角度来看，VAE对数据做了有损压缩（低维隐空间）。另一方面，ARM和流模型可以用于无损压缩，因为它们能够提供精确的似然概率用于密度估计。虽然隐式模型则不能直接用于压缩，不过也有工作尝试使用GAN改进图像压缩[44]。流模型、预定义隐变量模型和EBM（如果使用隐变量）都可以用于表示学习，即学习一组随机变量，这些变量以某种方式总结数据或对数据中的元素进行解耦。至于什么是好的数据表示，这是另外的问题，可参考[45]。</p><h2 id=14-本书的目的和内容>1.4 本书的目的和内容<a hidden class=anchor aria-hidden=true href=#14-本书的目的和内容>#</a></h2><p>本书旨在介绍深度生成建模这一领域，让你相信生成建模的哲学，并展示它的美！深度生成建模将概率论、统计学、概率机器学习和深度学习结合在一个框架中。为了更好地理解本书的内容，代数和微积分、概率论和统计学、机器学习和深度学习的基础以及Python编程等方面的知识是必要的。书中所有代码片段均基于PyTorch编写，不过Keras、Tensorflow或JAX深度学习框架用户也足以理解代码。</p><p>本书不会专门回顾机器学习的基本概念以及深度神经网络的知识。我们将深入研究深度生成模型和训练算法。我们将讨论自回归模型（第2章）、流模型（第3章）、隐变量模型（第4章）、混合模型（第5章）、能量模型（第6章）和生成对抗网络（第7章），最后将介绍深度生成建模如何用于数据压缩（第8章），章节之间彼此独立，且都包含一般性的讨论和形式化的过程以及对应的代码。本书的目的是使读者真正理解深度生成式建模，不仅能推导出模型也能够用代码实现。本书的代码库为：<p style=text-align:center><a href=https://github.com/jmtomczak/intro_dgm>https://github.com/jmtomczak/intro_dgm</a>。</p></p><h2 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h2><div><font color=gray size=2><ol><li>Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow, and Rob Fergus. Intriguing properties of neural networks. In 2nd International Conference on Learning Representations, ICLR 2014, 2014.</li><li>Christopher M Bishop. Model-based machine learning. Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences, 371(1984):20120222, 2013.</li><li>Zoubin Ghahramani. Probabilistic machine learning and artificial intelligence. Nature, 521(7553):452–459, 2015.</li><li>Julia A Lasserre, Christopher M Bishop, and Thomas P Minka. Principled hybrids of generative and discriminative models. In 2006 IEEE Computer Society Conference on Computer Vision and Pattern Recognition (CVPR’06), volume 1, pages 87–94. IEEE, 2006.</li><li>Samuel Bowman, Luke Vilnis, Oriol Vinyals, Andrew Dai, Rafal Jozefowicz, and Samy Bengio. Generating sentences from a continuous space. In Proceedings of The 20th SIGNLL Conference on Computational Natural Language Learning, pages 10–21, 2016.</li><li>Ian J Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio. Generative adversarial networks. arXiv preprint arXiv:1406.2661, 2014.</li><li>Aaron van den Oord, Sander Dieleman, Heiga Zen, Karen Simonyan, Oriol Vinyals, Alex Graves, Nal Kalchbrenner, Andrew Senior, and Koray Kavukcuoglu. WaveNet: A generative model for raw audio. arXiv preprint arXiv:1609.03499, 2016.</li><li>Samarth Sinha, Sayna Ebrahimi, and Trevor Darrell. Variational adversarial active learning.
In Proceedings of the IEEE/CVF International Conference on Computer Vision, pages 5972–5981, 2019.</li><li>David Ha and Jürgen Schmidhuber. World models. arXiv preprint arXiv:1803.10122, 2018.</li><li>GraphVAE: Towards generation of small graphs using variational autoencoders, author=Simonovsky, Martin and Komodakis, Nikos, booktitle=International Conference on Artificial Neural Networks, pages=412–422, year=2018, organization=Springer.</li><li>Maximilian Ilse, Jakub M Tomczak, Christos Louizos, and Max Welling. DIVA: Domain invariant variational autoencoders. In Medical Imaging with Deep Learning, pages 322–348.
PMLR, 2020.</li><li>Aapo Hyvärinen and Peter Dayan. Estimation of non-normalized statistical models by score matching. Journal of Machine Learning Research, 6(4), 2005.</li><li>Yang Song and Stefano Ermon. Generative modeling by estimating gradients of the data distribution. arXiv preprint arXiv:1907.05600, 2019.</li><li>Yang Song, Jascha Sohl-Dickstein, Diederik P Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole. Score-based generative modeling through stochastic differential equations. In International Conference on Learning Representations, 2020.</li><li>Aaron Van Oord, Nal Kalchbrenner, and Koray Kavukcuoglu. Pixel recurrent neural networks.
In International Conference on Machine Learning, pages 1747–1756. PMLR, 2016.</li><li>Aäron van den Oord, Nal Kalchbrenner, Oriol Vinyals, Lasse Espeholt, Alex Graves, and Koray Kavukcuoglu. Conditional image generation with PixelCNN decoders. In Proceedings of the 30th International Conference on Neural Information Processing Systems, pages 4797–4805, 2016.</li><li>Oren Rippel and Ryan Prescott Adams. High-dimensional probability estimation with deep density models. arXiv preprint arXiv:1302.5125, 2013.</li><li>Laurent Dinh, David Krueger, and Yoshua Bengio. NICE: Non-linear independent components estimation. arXiv preprint arXiv:1410.8516, 2014.</li><li>Jakub M Tomczak and Max Welling. Improving variational auto-encoders using householder flow. arXiv preprint arXiv:1611.09630, 2016.</li><li>Danilo Rezende and Shakir Mohamed. Variational inference with normalizing flows. In International Conference on Machine Learning, pages 1530–1538. PMLR, 2015.</li><li>Rianne Van Den Berg, Leonard Hasenclever, Jakub M Tomczak, and Max Welling. Sylvester normalizing flows for variational inference. In 34th Conference on Uncertainty in Artificial Intelligence 2018, UAI 2018, pages 393–402. Association For Uncertainty in Artificial Intelligence (AUAI), 2018.</li><li>Emiel Hoogeboom, Victor Garcia Satorras, Jakub M Tomczak, and Max Welling. The convolution exponential and generalized Sylvester flows. arXiv preprint arXiv:2006.01910, 2020.</li><li>Laurent Dinh, Jascha Sohl-Dickstein, and Samy Bengio. Density estimation using Real NVP. arXiv preprint arXiv:1605.08803, 2016.</li><li>Jens Behrmann, Will Grathwohl, Ricky TQ Chen, David Duvenaud, and Jörn-Henrik Jacobsen. Invertible residual networks. In International Conference on Machine Learning, pages 573–582. PMLR, 2019.</li><li>Ricky TQ Chen, Jens Behrmann, David Duvenaud, and Jörn-Henrik Jacobsen. Residual flows for invertible generative modeling. arXiv preprint arXiv:1906.02735, 2019.</li><li>Yura Perugachi-Diaz, Jakub M Tomczak, and Sandjai Bhulai. Invertible DenseNets with Concatenated LipSwish. Advances in Neural Information Processing Systems, 2021.</li><li>Emiel Hoogeboom, Jorn WT Peters, Rianne van den Berg, and Max Welling. Integer discrete flows and lossless compression. arXiv preprint arXiv:1905.07376, 2019.</li><li>Jakub M Tomczak. General invertible transformations for flow-based generative modeling. INNF+, 2021.</li><li>Michael E Tipping and Christopher M Bishop. Probabilistic principal component analysis. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 61(3):611–622, 1999.</li><li>Diederik P Kingma and Max Welling. Auto-encoding variational Bayes. arXiv preprint arXiv:1312.6114, 2013.</li><li>Danilo Jimenez Rezende, Shakir Mohamed, and Daan Wierstra. Stochastic backpropagation and approximate inference in deep generative models. In International conference on machine learning, pages 1278–1286. PMLR, 2014.</li><li>Durk P Kingma, Tim Salimans, Rafal Jozefowicz, Xi Chen, Ilya Sutskever, and Max Welling. Improved variational inference with inverse autoregressive flow. Advances in Neural Information Processing Systems, 29:4743–4751, 2016.</li><li>Xi Chen, Diederik P Kingma, Tim Salimans, Yan Duan, Prafulla Dhariwal, John Schulman, Ilya Sutskever, and Pieter Abbeel. Variational lossy autoencoder. arXiv preprint arXiv:1611.02731, 2016.</li><li>Jakub Tomczak and Max Welling. VAE with a VampPrior. In International Conference on Artificial Intelligence and Statistics, pages 1214–1223. PMLR, 2018.</li><li>Ishaan Gulrajani, Kundan Kumar, Faruk Ahmed, Adrien Ali Taiga, Francesco Visin, David Vazquez, and Aaron Courville. PixelVAE: A latent variable model for natural images. arXiv preprint arXiv:1611.05013, 2016.</li><li>Tim R Davidson, Luca Falorsi, Nicola De Cao, Thomas Kipf, and Jakub M Tomczak. Hyperspherical variational auto-encoders. In 34th Conference on Uncertainty in Artificial Intelligence 2018, UAI 2018, pages 856–865. Association For Uncertainty in Artificial Intelligence (AUAI), 2018.</li><li>Edwin T Jaynes. Probability theory: The logic of science. Cambridge university press, 2003.</li><li>Yann LeCun, Sumit Chopra, Raia Hadsell, M Ranzato, and F Huang. A tutorial on energybased learning. Predicting structured data, 1(0), 2006.</li><li>David H Ackley, Geoffrey E Hinton, and Terrence J Sejnowski. A learning algorithm for Boltzmann machines. Cognitive science, 9(1):147–169, 1985.</li><li>Geoffrey E Hinton, Terrence J Sejnowski, et al. Learning and relearning in Boltzmann machines. Parallel distributed processing: Explorations in the microstructure of cognition, 1(282-317):2, 1986.</li><li>Geoffrey E Hinton. A practical guide to training restricted Boltzmann machines. In Neural networks: Tricks of the trade, pages 599–619. Springer, 2012.</li></ol></font></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ltecod.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/>深度生成模型</a></li></ul><nav class=paginav><a class=next href=https://ltecod.github.io/posts/2023/%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%B8%80/><span class=title>下一篇 »</span><br><span>【译】深度生成建模（一）：前言</span></a></nav></footer><div class=giscus><script>function getGiscusTheme(){const e=localStorage.getItem("pref-theme"),t=e==null||e=="light"?"light":"noborder_dark";return t}function setGiscusTheme(){function e(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}e({setConfig:{theme:getGiscusTheme()=="light"?"noborder_dark":"light"}})}const attrs={src:"https://giscus.app/client.js","data-repo":"LtECoD/LtECoD.github.io","data-repo-id":"R_kgDOKiPsWA","data-category":"Announcements","data-category-id":"DIC_kwDOKiPsWM4Caly0","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getGiscusTheme(),"data-lang":"zh-CN",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(attrs).forEach(([e,t])=>giscusScript.setAttribute(e,t)),document.body.appendChild(giscusScript);const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",setGiscusTheme)</script></div></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2023 <a href=https://ltecod.github.io>豌豆道场</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><span>·&nbsp;<a href=/copyright/>版权说明</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>